

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spin Dynamics of an anisotropic XY model on a Cayley Tree &mdash; pyTTN 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Nonadiabatic Dynamics of 24-mode Pyrazine" href="pyrazine.html" />
    <link rel="prev" title="Quench Dynamics: 1D Transverse Field Ising Model" href="tfim_tdvp.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pyTTN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Installation/index.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quickstart:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Quickstart</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#ground-state-calculations">Ground State Calculations</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#dynamics-calculations">Dynamics Calculations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tfim_tdvp.html">Quench Dynamics: 1D Transverse Field Ising Model</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Spin Dynamics of an anisotropic XY model on a Cayley Tree</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Contents">Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Importing-the-Package">Importing the Package</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Setting-up-the-System-and-Hamiltonian">Setting up the System and Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Preparing-the-Initial-Wavefunction">Preparing the Initial Wavefunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Preparing-the-sop_operator-Hamiltonian">Preparing the <code class="docutils literal notranslate"><span class="pre">sop_operator</span></code> Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Setting-up-Observables">Setting up Observables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Setting-up-and-Performing-Time-Evolution">Setting up and Performing Time Evolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pyrazine.html">Nonadiabatic Dynamics of 24-mode Pyrazine</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#non-markovian-open-quantum-system-dynamics">Non-Markovian Open Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#using-the-multiset-ansatz">Using the Multiset Ansatz</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/index.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">pyTTN API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pyttn/API%20Outline.html">API Outline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyttn/index.html">API Documents</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyTTN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Quickstart</a></li>
      <li class="breadcrumb-item active">Spin Dynamics of an anisotropic XY model on a Cayley Tree</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Quickstart/cayley_xy_tdvp.nblink.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Spin-Dynamics-of-an-anisotropic-XY-model-on-a-Cayley-Tree">
<h1>Spin Dynamics of an anisotropic XY model on a Cayley Tree<a class="headerlink" href="#Spin-Dynamics-of-an-anisotropic-XY-model-on-a-Cayley-Tree" title="Link to this heading"></a></h1>
<p>A quick introduction on how to use pyTTN to perform calculations using Tree Tensor Network states. In this tutorial we demonstrate how to use pyTTN to evaluate the real time spin-dynamics of an anisotropic XY model on a Cayley Tree. Here we consider a Hamiltonian of the form:</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \sum_{\langle i,j \rangle}\left( (1-\eta)\hat{S}_{xi}\hat{S}_{xj}+(1+\eta)\hat{S}_{yi}\hat{S}_{yj}\right)  +\sum_{i} \hat{S}_{zi}\]</div>
<p>In this example, we consider a depth 6 tree. Due to the increased complexity of indexing a Cayley tree, this example highlights some more advanced features of the pyTTN library.</p>
<section id="Contents">
<h2>Contents<a class="headerlink" href="#Contents" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#Importing-the-Package"><span class="std std-ref">Importing the Package</span></a></p></li>
<li><p><a class="reference internal" href="#Setting-up-the-System-and-Hamiltonian"><span class="std std-ref">Setting up the System and Hamiltonian</span></a></p></li>
<li><p><a class="reference internal" href="#Preparing-the-Initial-Wavefunction"><span class="std std-ref">Preparing the Initial Wavefunction</span></a></p></li>
<li><p><cite>Preparing the ``sop_operator`</cite> Representation of the Hamiltonian &lt;#preparing-the-sop_operator-hamiltonian&gt;`__</p></li>
<li><p><a class="reference internal" href="#Setting-up-Observables"><span class="std std-ref">Setting up Observables</span></a></p></li>
<li><p><a class="reference internal" href="#Setting-up-and-Performing-Time-Evolution"><span class="std std-ref">Setting up and Performing Time Evolution</span></a></p></li>
</ol>
</section>
<section id="Importing-the-Package">
<h2>Importing the Package<a class="headerlink" href="#Importing-the-Package" title="Link to this heading"></a></h2>
<p>We start by importing the required modules for this example</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OMP_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;1&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="kn">import</span><span class="w"> </span><span class="nn">pyttn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyttn.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">visualise_tree</span>
</pre></div>
</div>
</div>
</section>
<section id="Setting-up-the-System-and-Hamiltonian">
<h2>Setting up the System and Hamiltonian<a class="headerlink" href="#Setting-up-the-System-and-Hamiltonian" title="Link to this heading"></a></h2>
<p>We start by setting up the <code class="docutils literal notranslate"><span class="pre">system_modes</span></code> object that tells pyTTN the type of operators to expect, and local Hilbert space dimension associated with each mode. For the case of a depth 6 Cayley tree of degree 3, we have a asystem containing a total of <span class="math notranslate nohighlight">\(N=94\)</span> spin-<span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>. The system can readily be set up as follows</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define number of modes</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span>

<span class="c1"># Initialise system information variable as a set of N modes</span>
<span class="n">sysinf</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">system_modes</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Specify that each mode is a two level system</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">sysinf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">spin_mode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We now prepare the system Hamiltonian through the use of the <code class="docutils literal notranslate"><span class="pre">SOP</span></code> class. This makes use of a string representation of the Hamiltonian, that is later converted into a form necessary for performing calculations. For more details on the generation of operators see the <a class="reference external" href="file/../operator_generation.ipynb">tutorial on operator generation</a>. Here we first introduce some a function that constructs an ntree with the connectivity of the Cayley tree and returns a connectivity graph of the network</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><br/><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_cayley_connectivity</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_nskip</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="n">degree</span><span class="o">*</span><span class="p">(</span><span class="n">degree</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1">#unpacks the cayley tree index into a single integer</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_index</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#figure out how many terms are in the Cayley tree of the given size</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">get_nskip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="p">[(</span><span class="n">degree</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)))]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">c</span>

    <span class="c1">#insert the root node into the ntree</span>
    <span class="n">topo</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">ntree</span><span class="p">(</span><span class="s1">&#39;(1)&#39;</span><span class="p">)</span>

    <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#now build each of the Layers around the tree</span>
    <span class="k">if</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#add the first layer</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
            <span class="n">topo</span><span class="p">()</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>

        <span class="c1">#now attempt to add all other layers to the tree</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1">#get all of the leaves of the the tree with the current number of layers</span>
            <span class="n">leaf_indices</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">leaf_indices</span><span class="p">()</span>

            <span class="c1">#now iterate over each leaf and add its children</span>
            <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">leaf_indices</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">li</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">topo</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">li</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">li</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">inds</span><span class="p">,</span> <span class="n">topo</span>
<br/><br/></pre></div>
</div>
</div>
<p>Now we actually go ahead and set up the Hamiltonian</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eta</span> <span class="o">=</span> <span class="mf">0.04</span>

<span class="n">depth</span><span class="o">=</span><span class="mi">6</span>
<span class="n">degree</span><span class="o">=</span><span class="mi">3</span>

<span class="c1">#get properties of the cayley tree</span>
<span class="n">inds</span><span class="p">,</span> <span class="n">topo</span> <span class="o">=</span> <span class="n">get_cayley_connectivity</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>

<span class="c1">#set up the system Hamiltonian</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">SOP</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1">#add on the onsite fields</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">H</span> <span class="o">+=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sz&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
    <span class="n">H</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sx&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sx&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">H</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sy&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sy&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<br/><br/></pre></div>
</div>
</div>
</section>
<section id="Preparing-the-Initial-Wavefunction">
<h2>Preparing the Initial Wavefunction<a class="headerlink" href="#Preparing-the-Initial-Wavefunction" title="Link to this heading"></a></h2>
<p>We now prepare the initial wavefunction. This requires a two-step process, first we define the tree topology to use for this calculation through the use of the <code class="docutils literal notranslate"><span class="pre">ntree</span></code> class (which for this example we choose to be an MPS), following which we construct the <code class="docutils literal notranslate"><span class="pre">ttn</span></code> object that actually represents the wavefunction. In this example we intend to use a subspace expansion based in order to expand bond dimension throughout the TDVP loop. In order to do this, we define an additional <code class="docutils literal notranslate"><span class="pre">ntree</span></code> object
with the same structure but different values defining the maximum allowed dimension of any bond in the network. For more details one the construct of tree topologies see the <a class="reference external" href="file/../tree_topologies.ipynb">tutorial on tree topologies</a>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initial bond dimension</span>
<span class="n">chi</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1">#maximum bond dimension</span>
<span class="n">chi_max</span> <span class="o">=</span> <span class="mi">32</span>

<span class="c1"># Vector of dimensions of the local Hilbert space in the physical nodes</span>
<span class="n">dims</span> <span class="o">=</span> <span class="n">sysinf</span><span class="o">.</span><span class="n">mode_dimensions</span><span class="p">()</span>

<span class="c1">#now construct an ntree object storing the MPS topology using the ntreeBuilder class</span>
<span class="n">_</span><span class="p">,</span> <span class="n">topo</span> <span class="o">=</span> <span class="n">get_cayley_connectivity</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="n">chi</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">get_cayley_connectivity</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="n">chi_max</span><span class="p">)</span>


<span class="c1">#now we need to go ahead and add the physical degrees of freedom to each node in the Cayley tree.</span>
<span class="c1">#to do this in the correct order we will traverse the ntree depth first search order and append</span>
<span class="c1">#the index of each node to the indices array</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">dfs</span><span class="p">():</span>
    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">index</span><span class="p">())</span>

<span class="c1">#here we iterate in the reverse order and add the local physical mode node at the front</span>
<span class="c1">#which ensures that we insert the nodes in the correct order.</span>
<span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span><span class="o">.</span><span class="n">insert_front</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
    <span class="n">capacity</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span><span class="o">.</span><span class="n">insert_front</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

<span class="c1">#now allocate the wavefunction object.  And allocate it so that each tensor is filled with random values</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">ttn</span><span class="p">(</span><span class="n">topo</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

<span class="c1">#and set up the system to be in the state where all spins are down except for the central spin which is up.</span>
<span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">A</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>When creating the <code class="docutils literal notranslate"><span class="pre">ttn</span></code> object, tensors will be constructed with the sizes defined in <code class="docutils literal notranslate"><span class="pre">topo</span></code> but with enough space allocated to store the tensors defined in <code class="docutils literal notranslate"><span class="pre">capacity</span></code>.</p>
</section>
<section id="Preparing-the-sop_operator-Hamiltonian">
<h2>Preparing the <code class="docutils literal notranslate"><span class="pre">sop_operator</span></code> Hamiltonian<a class="headerlink" href="#Preparing-the-sop_operator-Hamiltonian" title="Link to this heading"></a></h2>
<p>Now before we are ready to set up and perform the TDVP loop, we first need to convert the Hamiltonian into a form that can be used to efficiently within the TDVP algorithm. Here we set the Hamiltonian up as a Hierarchical Sum-of-Product operator by using the default call to sop_operator. However, we are not yet in a situation where this will give us the expected results.</p>
<p>This is the case as we are currently in a situation where the tree nodes are ordered in a depth first search traversal order but from the definition of the Cayley tree Hamiltonian and the <code class="docutils literal notranslate"><span class="pre">sysinf</span></code> object, the modes are indexed in a breadth first search order. To remedy this issue, we need to tell the sysinf object how to map modes from its current ordering to the ordering expected for the tree structure.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#traverse the nodes in depth first search order and create a dictionary storing the node and the index the order in which it was reach</span>
<span class="n">dict_dfs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">c</span><span class="o">=</span><span class="mi">0</span>
<span class="k">for</span>  <span class="n">i</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">dfs</span><span class="p">():</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()):</span>
        <span class="n">dict_dfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span>

<span class="n">ordering</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#now iterate over it in bfs ordering and for the ith leaf in bfs order set it to point to the index in dfs order</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">bfs</span><span class="p">():</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()):</span>
        <span class="n">ordering</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_dfs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="n">sysinf</span><span class="o">.</span><span class="n">mode_indices</span> <span class="o">=</span> <span class="n">ordering</span>
</pre></div>
</div>
</div>
<p>Now that we have done this mapping we are free to construct the SOP operator.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">sop_operator</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sysinf</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Setting-up-Observables">
<h2>Setting up Observables<a class="headerlink" href="#Setting-up-Observables" title="Link to this heading"></a></h2>
<p>In order to extract the spin-dynamics from this system we need to set up a set of observables to monitor. Here we will do this by constructing a set of operators defining the average magnetisation associated with each Layer of the Cayley tree. Additionally, we need to define the <code class="docutils literal notranslate"><span class="pre">matrix_element</span></code> object that will be used for evaluating the actual expectation values.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#set up the observables of interest</span>
<span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#add on the central spin magnetisation operator</span>
<span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyttn</span><span class="o">.</span><span class="n">site_operator</span><span class="p">(</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sz&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sysinf</span><span class="p">))</span>

<span class="n">linds</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">#for each other layer</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

    <span class="c1">#construct the SOP containing the average magnetisation of the layer</span>
    <span class="n">opS</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">SOP</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">linds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">linds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">opS</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">linds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">linds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">*</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sOP</span><span class="p">(</span><span class="s2">&quot;sz&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>

    <span class="c1">#and append this to the ops array as a sop_operator.</span>
    <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyttn</span><span class="o">.</span><span class="n">sop_operator</span><span class="p">(</span><span class="n">opS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sysinf</span><span class="p">))</span>


<span class="c1">#set up the matrix element evaluation code</span>
<span class="n">mel</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">matrix_element</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Setting-up-and-Performing-Time-Evolution">
<h2>Setting up and Performing Time Evolution<a class="headerlink" href="#Setting-up-and-Performing-Time-Evolution" title="Link to this heading"></a></h2>
<p>Now we can have everything we need to set up all of the objects required to perform the TDVP loop. Here we set up TDVP with the use of subspace expansion to expand bond dimensions throughout the update steps.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#set up parameters for the time evolution</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">nstep</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">observables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">nstep</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="c1">#set up the TDVP sweeping object.  Here we use subspace expansion evaluating the 6 largest eigenvalues of</span>
<span class="c1">#the two site energy variance using a krylov subspace of dimension 12.</span>
<span class="n">sweep</span> <span class="o">=</span> <span class="n">pyttn</span><span class="o">.</span><span class="n">tdvp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">krylov_dim</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>  <span class="n">expansion</span><span class="o">=</span><span class="s1">&#39;subspace&#39;</span><span class="p">,</span> <span class="n">subspace_neigs</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">subspace_krylov_dim</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1">#set up the subspace expansion parameters.  Here we expand bond dimension whenever a term in the</span>
<span class="c1">#two-site energy variance (that is not captured within the single-site spaces) has singular value &gt; 1e-5,</span>
<span class="c1">#and do not use natural populations to determine whether to spawn additional basis functions.</span>
<span class="n">sweep</span><span class="o">.</span><span class="n">spawning_threshold</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="n">sweep</span><span class="o">.</span><span class="n">unoccupied_threshold</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="n">sweep</span><span class="o">.</span><span class="n">minimum_unoccupied</span><span class="o">=</span><span class="mi">2</span>

<span class="c1">#integration timestep</span>
<span class="n">sweep</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
<span class="n">sweep</span><span class="o">.</span><span class="n">coefficient</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
</pre></div>
</div>
</div>
<p>Now we have everything needed to perform the TDVP loop. Here we now perform all of the required time evolution steps.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)):</span>
    <span class="n">observables</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mel</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">A</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
    <span class="c1">#perform the TDVP step</span>
    <span class="n">sweep</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="c1">#and print out the energy of the A tensor for the sweep</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;                                 </span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)):</span>
        <span class="n">observables</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mel</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
100
</pre></div></div>
</div>
<p>Now that we have computed the dynamics, we can plot the results:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nstep</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">observables</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/Quickstart_cayley_xy_tdvp_31_0.png" src="../_images/Quickstart_cayley_xy_tdvp_31_0.png" />
</div>
</div>
<p>Now finally, we will visualise what the subspace expansion scheme has done to the bond dimension of the TTN, using the <code class="docutils literal notranslate"><span class="pre">visualise_tree</span></code> function.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">visualise_tree</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">bond_prop</span><span class="o">=</span><span class="s2">&quot;bond dimension&quot;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label_all_bonds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/Quickstart_cayley_xy_tdvp_33_0.png" src="../_images/Quickstart_cayley_xy_tdvp_33_0.png" />
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tfim_tdvp.html" class="btn btn-neutral float-left" title="Quench Dynamics: 1D Transverse Field Ising Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pyrazine.html" class="btn btn-neutral float-right" title="Nonadiabatic Dynamics of 24-mode Pyrazine" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Lachlan Lindoy.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>