#ifndef TTNS_OPERATOR_GEN_LIB_COEFF_TYPE_HPP
#define TTNS_OPERATOR_GEN_LIB_COEFF_TYPE_HPP

#include <functional>
#include <utility>

#include <linalg/linalg.hpp>

namespace ttns
{

namespace primitive
{

template <typename T> class coeff;
template <typename T> std::ostream& operator<<(std::ostream& os, const coeff<T>& op); 

template <typename T>
class coeff
{
public:
    using real_type = typename linalg::get_real_type<T>::type;
    using function_type = std::function<T(const real_type& t)>;
public:
    coeff() : m_constant(T(1.0)), m_funcs(){}
    //constructors
    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff(const U& c) : m_constant(c), m_funcs(){}
    coeff(const function_type& f) : m_constant(T(0.0)), m_funcs() {m_funcs.push_back(std::make_pair(T(1.0), f));}
    coeff(function_type&& f) : m_constant(T(0.0)), m_funcs() {m_funcs.push_back(std::make_pair(T(1.0), std::move(f))); }
    template <typename Func>
    coeff(Func&& f) : m_constant(T(0.0)), m_funcs() {m_funcs.push_back(std::make_pair(T(1.0), function_type(std::forward<Func>(f)))); }

    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff(const coeff<U>& o)
    {
        m_constant = o.constant();
        m_funcs.resize(o.funcs().size());
        for(size_t i = 0; i < o.funcs().size(); ++i)
        {
            const auto& ai = o.funcs()[i];
            const auto& aif = std::get<1>(ai);
            m_funcs.push_back(std::make_pair(T(std::get<0>(ai)), function_type([aif](const real_type& t){return T(aif(t));})));
        }
    }

    coeff(const coeff& o) = default;
    coeff(coeff&& o) = default;

    //assignment operators
    coeff& operator=(const coeff& o) = default;
    coeff& operator=(coeff&& o) = default;


    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator=(const coeff<U>& o)
    {
        m_funcs.clear();
        m_constant = o.constant();
        m_funcs.resize(o.funcs().size());
        for(size_t i = 0; i < o.funcs().size(); ++i)
        {
            const auto& ai = o.funcs()[i];
            const auto& aif = std::get<1>(ai);
            m_funcs.push_back(std::make_pair(T(std::get<0>(ai)), function_type([aif](const real_type& t){return T(aif(t));})));
        }
        return *this;
    }

    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator=(const T& c)
    {
        m_funcs.clear();
        m_constant=c;
        return *this;
    }

    coeff& operator=(const function_type& f)
    {
        m_funcs.clear();
        m_constant=T(0.0);
        m_funcs.push_back(std::make_pair(T(1.0), f));
        return *this;
    }

    coeff& operator=(function_type&& f)
    {
        m_funcs.clear();
        m_constant=T(0.0);
        m_funcs.push_back(std::make_pair(T(1.0), std::move(f)));
        return *this;
    }

    const T& constant() const{return m_constant;}
    T& constant(){return m_constant;}

    const std::vector<std::pair<T, function_type>>& funcs() const{return m_funcs;}
    std::vector<std::pair<T, function_type>>& funcs(){return m_funcs;}
public:      
    //arithemetic operators for updating coefficients types. 
    //inplace addition, subtraction, multiplication and division of scalars
    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator+=(const U& c)
    {
        m_constant += c;
        return *this;
    }
    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator-=(const U& c)
    {
        m_constant -= c;
        return *this;
    }
    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator*=(const U& c)
    {
        m_constant *= c;
        for(size_t i = 0; i < m_funcs.size(); ++i)
        {
            std::get<0>(m_funcs[i]) *= c;
        }
        return *this;
    }
    template <typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
    coeff& operator/=(const U& c)
    {
        m_constant /= c;
        for(size_t i = 0; i < m_funcs.size(); ++i)
        {
            std::get<0>(m_funcs[i]) /= c;
        }
        return *this;
    }

    //inplace addition and subtraction of functions
    coeff& operator+=(const function_type& f)
    {
        m_funcs.push_back(std::make_pair(T(1.0), f));
        return *this;
    }
    coeff& operator-=(const function_type& f)
    {
        m_funcs.push_back(std::make_pair(T(-1.0), f));
        return *this;
    }
    coeff& operator+=(function_type&& f)
    {
        m_funcs.push_back(std::make_pair(T(1.0), std::move(f)));
        return *this;
    }
    coeff& operator-=(function_type&& f)
    {
        m_funcs.push_back(std::make_pair(T(-1.0), std::move(f)));
        return *this;
    }

    //inplace addition and subtraction of other coeffs
    coeff& operator+=(const coeff<T>& o)
    {
        m_constant += o.m_constant;
        for(size_t i = 0; i < o.m_funcs.size(); ++i)
        {
            m_funcs.push_back(o.m_funcs[i]);
        }
        return *this;
    }
    coeff& operator-=(const coeff<T>& o)
    {
        m_constant -= o.m_constant;
        for(size_t i = 0; i < o.m_funcs.size(); ++i)
        {
            m_funcs.push_back(std::make_pair(-1.0*std::get<0>(o.m_funcs[i]), std::get<1>(o.m_funcs[i])));
        }
        return *this;
    }

    coeff& operator*=(const coeff<T>& o)
    {
        if(o.m_funcs.size() == 0)
        {
            m_constant *= o.m_constant;
            if(std::abs(o.m_constant) < 1e-14)
            {
                m_funcs.clear();
            }
            else
            {
                for(size_t i = 0; i < m_funcs.size(); ++i)
                {
                    std::get<0>(m_funcs[i])*=o.m_constant;
                }
            }
        }
        else if(m_funcs.size() == 0)
        {
            if(std::abs(m_constant)  < 1e-14){}
            else
            {
                for(size_t i = 0; i < o.m_funcs.size(); ++i)
                {
                    m_funcs[i].push_back(std::make_pair(m_constant*std::get<0>(o.m_funcs[i]), std::get<1>(o.m_funcs[i])));
                }

                m_constant *= o.m_constant;
            }
        }
        else
        {
            std::vector<function_type> funcs;
            //now add on the acoeff terms
            if(std::abs(m_constant) > 1e-14)
            {
                for(size_t i = 0; i < o.m_funcs.size(); ++i)
                {
                    const auto& bi = o.m_funcs[i];
                    funcs.push_back(std::make_pair(std::get<0>(bi)*m_constant, std::get<1>(bi)));
                }
            }
            if(std::abs(o.m_constant) > 1e-14)
            {
                for(size_t i = 0; i < m_funcs.size(); ++i)
                {
                    const auto& ai = m_funcs[i];
                    funcs.push_back(std::make_pair(std::get<0>(ai)*o.m_constant, std::get<1>(ai)));
                }
            }
            for(size_t i = 0; i < m_funcs.size(); ++i)
            {
                const auto& ai = m_funcs[i];
                for(size_t j = 0; j< o.m_funcs.size(); ++j)
                {
                    const auto& bj = o.m_funcs[j];
                    funcs.push_back(std::make_pair(std::get<0>(ai)*std::get<0>(bj), std::function<T(const real_type&)>([ai, bj](const real_type& t){return ai[t]*bj[t];})));
                }
            }
            m_funcs.clear();
            m_funcs = funcs;
            m_constant *= o.m_constant;
        }
        return *this;
    }

public:
    void clear()
    {
        m_constant = T(0.0);
        m_funcs.clear();
    }

    bool is_zero(real_type tol = 1e-14) const
    {
        if(m_funcs.size() == 0){return std::abs(m_constant) < tol;}
        return false;
    }

    bool is_positive() const{return std::real(m_constant) >= 0;}

public:
    //Functions for accessing the coefficient
    T operator()(real_type t) const
    {
        T ret = m_constant;
        for(size_t i = 0; i < m_funcs.size(); ++i)
        {
            ret += std::get<0>(m_funcs[i]) * (std::get<1>(m_funcs[i])(t));
        }
        return ret;
    }

    T operator()() const
    {
        ASSERT(!this->is_time_dependent(), "Cannot evaluate coefficient without time if it is time dependent.");
        return m_constant;
    }

    bool is_time_dependent() const{return m_funcs.size() > 0;}
    friend std::ostream& operator<< <T>(std::ostream& os, const coeff<T>& op);

#ifdef CEREAL_LIBRARY_FOUND
public:
    template <typename archive>
    void serialize(archive& ar)
    {
        CALL_AND_HANDLE(ar(cereal::make_nvp("coeff", m_constant)), "Failed to serialise sum of product operator.  Failed to serialise array of product operators.");
        CALL_AND_HANDLE(ar(cereal::make_nvp("funcs", m_funcs)), "Failed to serialise sum of product operator.  Failed to serialise array of product operators.");
    }
#endif
protected:
    T m_constant;
    std::vector<std::pair<T, function_type>> m_funcs;
};

template <typename T> 
std::ostream& operator<<(std::ostream& os, const ttns::primitive::coeff<T>& op)
{
    os << "(" << op.constant() << " + " << op.funcs().size() << " functions)";
    return os;
}

}
}

//arithemetic operators for updating coefficients types. 
//addition, subtraction, multiplication and division of scalars
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator+(const ttns::primitive::coeff<T>& o, const U& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator+(const U& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator-(const ttns::primitive::coeff<T>& o, const U& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret -= c;
    return ret;
}
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator-(const U& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(c);
    ret -= o;
    return ret;
}


template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator*(const ttns::primitive::coeff<T>& o, const U& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret *= c;
    return ret;
}
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator*(const U& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret *= c;
    return ret;
}



template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator/(const ttns::primitive::coeff<T>& o, const U& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret /= c;
    return ret;
}
template <typename T, typename U, typename = typename std::enable_if<linalg::is_number<U>::value, void>::type>
ttns::primitive::coeff<T> operator/(const U& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret /= c;
    return ret;
}


//addition of functions
template <typename T>
ttns::primitive::coeff<T> operator+(const ttns::primitive::coeff<T>& o, const std::function<T(const typename linalg::get_real_type<T>::type&)>& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}
template <typename T>
ttns::primitive::coeff<T> operator+(const std::function<T(const typename linalg::get_real_type<T>::type&)>& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator+(const ttns::primitive::coeff<T>& o, std::function<T(const typename linalg::get_real_type<T>::type&)>& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}
template <typename T>
ttns::primitive::coeff<T> operator+(std::function<T(const typename linalg::get_real_type<T>::type&)>&& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator-(const ttns::primitive::coeff<T>& o, const std::function<T(const typename linalg::get_real_type<T>::type&)>& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret -= c;
    return ret;
}
template <typename T>
ttns::primitive::coeff<T> operator-(const std::function<T(const typename linalg::get_real_type<T>::type&)>& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(c);
    ret -= o;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator-(const ttns::primitive::coeff<T>& o, std::function<T(const typename linalg::get_real_type<T>::type&)>&& c)
{
    ttns::primitive::coeff<T> ret(o);
    ret -= std::move(c);
    return ret;
}
template <typename T>
ttns::primitive::coeff<T> operator-(std::function<T(const typename linalg::get_real_type<T>::type&)>&& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(std::move(c));
    ret -= o;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator+(const ttns::primitive::coeff<T>& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(o);
    ret += c;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator-(const ttns::primitive::coeff<T>& c, const ttns::primitive::coeff<T>& o)
{
    ttns::primitive::coeff<T> ret(c);
    ret -= o;
    return ret;
}

template <typename T>
ttns::primitive::coeff<T> operator*(const ttns::primitive::coeff<T>& a, const ttns::primitive::coeff<T>& b)
{
    using real_type = typename linalg::get_real_type<T>::type;
    ttns::primitive::coeff<T> ret(a.constant()*b.constant());
    //now add on the acoeff terms
    if(std::abs(a.constant()) > 1e-14)
    {
        for(size_t i = 0; i < b.funcs().size(); ++i)
        {
            const auto& bi = b.funcs()[i];
            ret.funcs().push_back(std::make_pair(std::get<0>(bi)*a.constant(), std::get<1>(bi)));
        }
    }
    if(std::abs(b.constant()) > 1e-14)
    {
        for(size_t i = 0; i < a.funcs().size(); ++i)
        {
            const auto& ai = a.funcs()[i];
            ret.funcs().push_back(std::make_pair(std::get<0>(ai)*b.constant(), std::get<1>(ai)));
        }
    }
    for(size_t i = 0; i < a.funcs().size(); ++i)
    {
        const auto& ai = a.funcs()[i];
        const auto& aif = std::get<1>(ai);
        for(size_t j = 0; j< b.funcs().size(); ++j)
        {
            const auto& bj = b.funcs()[j];
            const auto& bjf = std::get<1>(bj);
            ret.funcs().push_back(std::make_pair(std::get<0>(ai)*std::get<0>(bj), std::function<T(const real_type&)>([aif, bjf](const real_type& t){return aif[t]*bjf[t];})));
        }
    }
    return ret;
}

#endif  //TTNS_OPERATOR_GEN_LIB_COEFF_TYPE_HPP

